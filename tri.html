<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas + D3 Force Graph</title>
    <script src="graph.js"></script>
    <script src="tree.js"></script>
    <script src="force.js"></script>
    <script src="swissgl.js"></script>
    <style>
        body { margin: 0; background: #1a1a1a; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh;}
    </style>
</head>
<body>
    <canvas></canvas>
    <div id="status" style="position: absolute; bottom: 10px; left: 10px; color: white; font-family: monospace; z-index: 100;">status</div>
    <script>
        "use strict";
        const canvas = document.querySelector('canvas');
        //const ctx = canvas.getContext('2d');
        const glsl = SwissGL(canvas);


        //const rule = 1062;
        //const rule = 2210;
        //const rule = 2222;
        //const rule = 2182; !
        //const rule = 2183;//
        //const rule = 2236;
        //const rule = 1111;
        //const rule = 618;
        //1033 4118 2199
//0b0100_0110_0010_0101 !        
//0b0100_0110_0010_0001 !
//0b0110_0110_0010_0001
//0b0101_0110_1100_1100
//0b0000_1100_1011_1100 - interesting

        const rule = 2182;
        const GrowthLimit = 10000;

        let graph, simulation;
        const status = document.getElementById('status');

        async function init() {
            graph = new GrowingGraph(rule);
            //while (graph.nodes.length < GrowthLimit) graph.grow();
            const {instance} = await WebAssembly.instantiateStreaming(fetch('main.wasm'));
            simulation = new GraphLayout(graph.nodes, instance);

            requestAnimationFrame(frame);
        }
        init();

        const points = new Float32Array(256*256*4);
        const links = new Int32Array(256*256*2);

        function frame(time) {
            requestAnimationFrame(frame);
            if (time > 1000 && graph.nodes.length <= GrowthLimit) {
                graph.grow();
            }
            simulation.tick(2);
        
            const DPR = devicePixelRatio;
            const width = canvas.width = window.innerWidth*DPR;
            const height = canvas.height = window.innerHeight*DPR;

            const {tree} = simulation;

            const {bounds, extent} = tree;
            const center = bounds.lo.map((l,i)=>(l+bounds.hi[i])/2);

            const {pointN, pos} = simulation;
            const {lastGen} = graph;
            let linkN = 0;
            for (let i=0; i<pointN; ++i) {
                for (let c=0; c<3; ++c) {
                    points[i*4+c] = pos[i*3+c];
                }
                points[i*4+3] = graph.nodes[i].gen;
                for (const j of graph.nodes[i]) {
                    if (i>j) continue;
                    links[linkN*2] = i; links[linkN*2+1] = j;
                    linkN++;
                }
            }
            const pointsTex = glsl({}, {data:points, size:[256, 256], format:'rgba32f', tag:'points'});
            const linksTex = glsl({}, {data:links, size:[256, 256], format:'rg32i', tag:'links'})
            glsl({pointsTex, linksTex, center, extent, time, Grid:[linkN], Blend:'s*sa+d*(1-sa)', Aspect:'fit', VP:`
                #define id2xy(id) ivec2((id)&0xff, (id)>>8)
                ivec2 link = linksTex(id2xy(ID.x)).xy;
                vec2 p0 = pointsTex(id2xy(link.x)).xy;
                vec2 p1 = pointsTex(id2xy(link.y)).xy;
                vec2 dp = normalize(p1-p0);
                vec2 p = mix(p0, p1, UV.x) + vec2(-dp.y, dp.x)*XY.y;
                VPos.xy = 1.9*(p.xy-center.xy)/(extent+30.);
            `, FP:`1.`});
            glsl({pointsTex, lastGen, center, extent, time, Grid:[pointN], Blend:'s*sa+d*(1-sa)', Aspect:'fit', VP:`
            vec3 color_map(float t) {
                const vec3 c0 = vec3(0.05873234392399702, 0.02333670892565664, 0.5433401826748754);
                const vec3 c1 = vec3(2.176514634195958, 0.2383834171260182, 0.7539604599784036);
                const vec3 c2 = vec3(-2.689460476458034, -7.455851135738909, 3.110799939717086);
                const vec3 c3 = vec3(6.130348345893603, 42.3461881477227, -28.51885465332158);
                const vec3 c4 = vec3(-11.10743619062271, -82.66631109428045, 60.13984767418263);
                const vec3 c5 = vec3(10.02306557647065, 71.41361770095349, -54.07218655560067);
                const vec3 c6 = vec3(-3.658713842777788, -22.93153465461149, 18.19190778539828);
                return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));
            }
            void vertex() {
                #define id2xy(id) ivec2((id)&0xff, (id)>>8)
                vec4 p = pointsTex(id2xy(ID.x));
                varying vec3 color = color_map(p.w/(lastGen+1.));
                //varying vec3 color = color_map(float(ID.x)/float(Grid.x-1));
                VPos.xy = 1.9*(p.xy-center.xy+XY*10.0)/(extent+30.);
            }`, FP:`vec4(color,1)*smoothstep(1.0, 0.8, length(XY))`});

            /*
            if (0) {
                ctx.lineWidth = 1/scale;
                ctx.strokeStyle = '#5f5';
                ctx.fillStyle = 'rgba(40,200,40,0.5)';
                for (let i=0; i<tree.nodes.length; ++i) {
                    //if (tree.nodes[i].next != i+1) continue; // skip non-leaves
                    const node = tree.nodes[i];
                    const [x, y] = node.pos;
                    const s = 1<<node.level;
                    const w = tree.extent;
                    //ctx.strokeRect(x, y, w/s, w/s);
                    const cx=centers[i*3], cy=centers[i*3+1];
                    const mass = node.end-node.start;
                    ctx.beginPath()
                    ctx.arc(cx, cy, 4*Math.sqrt(mass), 0, Math.PI * 2);
                    ctx.fill();

                    ctx.beginPath()
                    ctx.moveTo(cx, cy);
                    const pi = node.parentIdx;
                    const px=centers[pi*3], py=centers[pi*3+1];
                    ctx.lineTo(px, py);
                    ctx.stroke()
                    
                }
            }

            ctx.resetTransform();
            ctx.font = "50px Arial";
            ctx.fillStyle = "#fff";
            ctx.fillText(`node n: ${graph.nodes.length}`,40,60);
            ctx.fillStyle = "#aaa";
            ctx.fillText(`rule: ${rule}`,40,120); */
        }

    </script>
</body>
</html>